<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    //1，使用setTimeout
    // setTimeout(()=>{
    //     console.log('Hello World');
    // },1000)

    //参数 -> 函数(resolve,reject)
    //resolve,reject他们本身就是函数


    new Promise((resolve,reject)=> {
        setTimeout(() => {
            resolve()

        }, 1000)
    }).then(()=>{
        //第一次处理的代码
        console.log('Hello World');
        console.log('Hello World');
        console.log('Hello World');
        console.log('Hello World');
        console.log('Hello World');

        return new Promise((resolve,reject)=>{
            setTimeout(()=>{
                resolve()
            },1000)
        })
    }).then(()=>{
        //第二次处理的代码
        console.log('Hello Python');
        console.log('Hello Python');
        console.log('Hello Python');
        console.log('Hello Python');
        console.log('Hello Python');

        return new Promise((resolve,reject)=>{
            setTimeout(()=>{
                resolve()
            })
        })
    }).then(()=>{
        //第三次处理的代码
        console.log('Hello Vue');
        console.log('Hello Vue');
        console.log('Hello Vue');
        console.log('Hello Vue');
        console.log('Hello Vue');
    })
//什么时候用到promise？
    // 一般情况下是有异步操作时使用promise操作进行封装
    //new ->构造函数（1，保持了一些状态信息，2，执行传入的函数）
    //在执行传入的回调函数时，会传入两个参数，resolve，reject，本身又是函数
    new Promise((resolve,reject)=>{
        setTimeout((data)=>{
            //成功的时候调用resolve
            // resolve("Hello World")
            //失败的时候调用reject
            reject("error message")
        },1000)
    }).then((data)=>{
        //1.100行的处理代码
        console.log(data);
        console.log(data);
        console.log(data);
        console.log(data);
        console.log(data);
        console.log(data);

    }).catch((err)=>{
        console.log(err);
    })

</script>


</body>
</html>
